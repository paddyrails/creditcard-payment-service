package com.creditcard.payment.service;
import com.creditcard.payment.dto.*;import com.creditcard.payment.exception.*;import com.creditcard.payment.model.*;import com.creditcard.payment.repository.PaymentRepository;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.time.LocalDateTime;import java.util.*;import java.util.stream.Collectors;
@Service @RequiredArgsConstructor @Slf4j @Transactional
public class PaymentServiceImpl implements PaymentService {
    private final PaymentRepository repo;
    public PaymentDTO makePayment(CreatePaymentRequest req){Payment p=Payment.builder().accountId(req.getAccountId()).paymentReference(genRef()).amount(req.getAmount()).paymentMethod(req.getPaymentMethod()).paymentType(req.getPaymentType()).sourceAccount(req.getSourceAccount()).status(PaymentStatus.PROCESSING).build();Payment saved=repo.save(p);saved.setStatus(PaymentStatus.COMPLETED);saved.setProcessedDate(LocalDateTime.now());saved.setConfirmationNumber(genConf());return map(repo.save(saved));}
    public PaymentDTO schedulePayment(CreatePaymentRequest req){if(req.getScheduledDate()==null||req.getScheduledDate().isBefore(LocalDateTime.now()))throw new InvalidPaymentException("Invalid date");Payment p=Payment.builder().accountId(req.getAccountId()).paymentReference(genRef()).amount(req.getAmount()).paymentMethod(req.getPaymentMethod()).paymentType(req.getPaymentType()).sourceAccount(req.getSourceAccount()).scheduledDate(req.getScheduledDate()).status(PaymentStatus.SCHEDULED).build();return map(repo.save(p));}
    @Transactional(readOnly=true) public PaymentDTO getPaymentById(String id){return map(repo.findById(id).orElseThrow(()->new PaymentNotFoundException("Not found")));}
    @Transactional(readOnly=true) public List<PaymentDTO> getPaymentsByAccountId(String aid){return repo.findByAccountIdOrderByCreatedAtDesc(aid).stream().map(this::map).collect(Collectors.toList());}
    @Transactional(readOnly=true) public List<PaymentDTO> getScheduledPayments(String aid){return repo.findByAccountIdAndStatus(aid,PaymentStatus.SCHEDULED).stream().map(this::map).collect(Collectors.toList());}
    public PaymentDTO cancelPayment(String id){Payment p=repo.findById(id).orElseThrow(()->new PaymentNotFoundException("Not found"));if(p.getStatus()!=PaymentStatus.SCHEDULED)throw new InvalidPaymentException("Cannot cancel");p.setStatus(PaymentStatus.CANCELLED);return map(repo.save(p));}
    @Scheduled(fixedRate=60000) public void processScheduledPayments(){List<Payment> scheduled=repo.findByScheduledDateBeforeAndStatus(LocalDateTime.now(),PaymentStatus.SCHEDULED);for(Payment p:scheduled){p.setStatus(PaymentStatus.COMPLETED);p.setProcessedDate(LocalDateTime.now());p.setConfirmationNumber(genConf());repo.save(p);log.info("Processed: {}",p.getPaymentReference());}}
    private String genRef(){return "PAY-"+System.currentTimeMillis();}
    private String genConf(){return "CONF-"+UUID.randomUUID().toString().substring(0,8).toUpperCase();}
    private String mask(String s){return s==null||s.length()<4?"****":"****"+s.substring(s.length()-4);}
    private PaymentDTO map(Payment p){return PaymentDTO.builder().id(p.getId()).accountId(p.getAccountId()).paymentReference(p.getPaymentReference()).amount(p.getAmount()).paymentMethod(p.getPaymentMethod()).paymentType(p.getPaymentType()).status(p.getStatus()).maskedSourceAccount(mask(p.getSourceAccount())).confirmationNumber(p.getConfirmationNumber()).scheduledDate(p.getScheduledDate()).processedDate(p.getProcessedDate()).createdAt(p.getCreatedAt()).build();}
}
